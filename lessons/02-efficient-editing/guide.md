# LazyVim 効率的編集操作ガイド

## 🎯 概要

LazyVimは従来のvim編集機能を大幅に強化し、現代的な開発環境を提供します。このガイドでは、LSP、Treesitter、各種プラグインを活用した効率的な編集方法を学習します。

## 🚀 LazyVim編集機能の基礎

### 編集支援システム

LazyVimの編集は以下のシステムが連携して動作します：

| システム | 役割 | 主な機能 |
|----------|------|----------|
| **LSP** | 言語解析 | エラー検出、補完、リファクタリング |
| **Treesitter** | 構文解析 | スマートな選択、ハイライト |
| **CMP** | 補完エンジン | コンテキスト補完 |
| **Telescope** | 検索・ナビゲーション | ファイル・シンボル検索 |

### 基本原則: オペレータ + モーション + LazyVim機能

```
[count] operator [count] motion + LazyVim enhancement
```

例：
- 従来: `dw` (単語削除)
- LazyVim: `dw` + LSPによるシンボル認識 + Treesitterによるスマート選択

## 📍 LazyVim高度移動コマンド

### 1. Treesitter拡張移動

LazyVimはTreesitterにより構文を理解した移動が可能：

| キー | 機能 | 説明 |
|------|------|------|
| `]m` | 次のメソッドへ | Treesitterによる関数認識 |
| `[m` | 前のメソッドへ | 構文解析による正確な移動 |
| `]c` | 次のクラスへ | クラス定義の自動認識 |
| `[c` | 前のクラスへ | 言語問わずクラス移動 |

### 2. LSPナビゲーション

| キー | 機能 | 説明 |
|------|------|------|
| `gd` | 定義ジャンプ | LSPによる正確な定義位置 |
| `gr` | 参照一覧 | 使用箇所をTelescope表示 |
| `gi` | 実装ジャンプ | インターフェース→実装 |
| `K` | ドキュメント表示 | ホバーでドキュメント |
| `<leader>ca` | コードアクション | 自動修正・リファクタリング |

### 3. 診断ナビゲーション

| キー | 機能 | 説明 |
|------|------|------|
| `]d` | 次の診断へ | エラー・警告への移動 |
| `[d` | 前の診断へ | 問題箇所の順次確認 |
| `<leader>xx` | 診断一覧 | Trouble.nvimで問題一覧 |

## ✏️ LazyVim編集オペレータ

### 1. 基本編集 + LSP支援

#### d (delete) - 削除 + スマート認識

| コマンド | LazyVim拡張 | 効果 |
|---------|-------------|------|
| `dw` | Treesitter単語認識 | 変数名、キーワードの正確な削除 |
| `dd` | LSP行診断クリア | 行削除 + エラー状態更新 |
| `daf` | Treesitter関数選択 | 関数全体を自動認識削除 |
| `dac` | Treesitterクラス選択 | クラス全体を自動削除 |

#### c (change) - 変更 + 補完

| コマンド | LazyVim拡張 | 効果 |
|---------|-------------|------|
| `cw` | LSP補完起動 | 単語変更 + 自動補完 |
| `cc` | スニペット対応 | 行変更 + スニペット補完 |
| `caf` | 関数置換 | 関数全体の置換 + LSP検証 |

#### y (yank) - コピー + システム統合

| コマンド | LazyVim拡張 | 効果 |
|---------|-------------|------|
| `yw` | システムクリップボード | 自動システムクリップボード連携 |
| `yy` | 改行保持 | 行コピー + 適切な改行処理 |
| `yaf` | 関数コピー | 関数全体の正確なコピー |

### 2. LazyVim特有テキストオブジェクト

#### Treesitterオブジェクト

| オブジェクト | 説明 | 例 |
|-------------|------|-----|
| `af` | 関数全体 | `daf` で関数削除 |
| `if` | 関数内部 | `cif` で関数内容変更 |
| `ac` | クラス全体 | `yac` でクラスコピー |
| `ic` | クラス内部 | `dic` でクラス内容削除 |
| `aa` | 引数（around） | `caa` で引数全体変更 |
| `ia` | 引数（inner） | `cia` で引数内容変更 |

#### LSPオブジェクト

| オブジェクト | 説明 | LazyVim特徴 |
|-------------|------|-------------|
| `is` | シンボル内部 | LSPによるシンボル認識 |
| `as` | シンボル全体 | 宣言含む全体選択 |

## 🔄 LazyVim自動化機能

### 1. 自動補完（nvim-cmp）

補完は自動起動、手動制御も可能：

| キー | 機能 |
|------|------|
| `<C-n>` | 次の候補 |
| `<C-p>` | 前の候補 |
| `<CR>` | 補完確定 |
| `<C-Space>` | 補完手動起動 |
| `<C-u>` | 補完ドキュメントスクロール |

### 2. スニペット（LuaSnip）

| キー | 機能 |
|------|------|
| `<Tab>` | 次のプレースホルダー |
| `<S-Tab>` | 前のプレースホルダー |
| `<C-k>` | スニペット展開 |

### 3. コメント機能（Comment.nvim）

言語を自動認識してコメント：

| キー | 機能 | 効果 |
|------|------|------|
| `gcc` | 行コメント切り替え | `//`, `#`, `--` など言語別 |
| `gbc` | ブロックコメント切り替え | `/* */`, `<!-- -->` など |
| `gc{motion}` | 範囲コメント | `gcap` で段落コメント |

## 🎨 ビジュアルモード + LazyVim

### ビジュアル選択の拡張

| キー | 機能 | LazyVim拡張 |
|------|------|-------------|
| `v` | 文字選択 | Treesitter境界認識 |
| `V` | 行選択 | 診断情報表示 |
| `<C-v>` | ブロック選択 | マルチカーソル風操作 |

### ビジュアルモード専用機能

| キー | 機能 |
|------|------|
| `gc` | 選択範囲コメント |
| `gS` | 選択範囲をサラウンド |
| `<` | 選択インデント減 |
| `>` | 選択インデント増 |
| `=` | 選択範囲自動フォーマット |

## ⚡ 高速編集パターン

### 1. LSP修正フロー

```
1. ]d        # 次のエラーへ移動
2. <leader>ca # コードアクション実行
3. <CR>       # 修正適用
4. ]d         # 次のエラーへ（繰り返し）
```

### 2. リファクタリングフロー

```
1. *         # カーソル下の単語をハイライト
2. cgn       # 次の一致を変更
3. .         # 変更を他の箇所に適用（繰り返し）
```

### 3. 関数編集フロー

```
1. ]m        # 次の関数へ移動
2. vaf       # 関数全体を選択
3. =         # 自動フォーマット
```

### 4. エラー修正フロー

```
1. <leader>xx # エラー一覧表示
2. <CR>       # エラー箇所にジャンプ
3. <leader>ca # 自動修正実行
```

## 🔧 LazyVim設定カスタマイズ

### よく使う編集マッピング

`~/.config/nvim/lua/config/keymaps.lua`に追加：

```lua
-- 効率的な編集キーマップ
vim.keymap.set("n", "<leader>rn", vim.lsp.buf.rename, { desc = "Rename symbol" })
vim.keymap.set("n", "<leader>rf", vim.lsp.buf.format, { desc = "Format buffer" })
vim.keymap.set("v", "<leader>rf", vim.lsp.buf.format, { desc = "Format selection" })

-- Treesitter関数移動
vim.keymap.set("n", "]f", function()
  require("nvim-treesitter.textobjects.move").goto_next_start("@function.outer")
end, { desc = "Next function" })

vim.keymap.set("n", "[f", function()
  require("nvim-treesitter.textobjects.move").goto_previous_start("@function.outer")
end, { desc = "Previous function" })
```

## 📊 編集効率測定

### 操作時間の目標

| 操作 | 目標時間 | LazyVim優位性 |
|------|----------|---------------|
| エラー修正 | 3秒以内 | LSP自動修正 |
| 関数移動 | 1秒以内 | Treesitter認識 |
| リファクタリング | 5秒以内 | LSPリネーム |
| コメント切り替え | 0.5秒 | 言語自動認識 |

## 🎯 実践練習のポイント

### 日次練習ルーチン

1. **LSPナビゲーション**: `gd` → `gr` → `K` のフロー
2. **Treesitter選択**: `vaf` → `=` でフォーマット
3. **エラー修正**: `]d` → `<leader>ca` で自動修正
4. **コメント操作**: `gcc` で言語別コメント

### 実際のコードでの練習

- **JavaScript/TypeScript**: LSP機能をフル活用
- **Python**: Treesitter選択でクラス・関数編集
- **HTML/CSS**: タグオブジェクトとサラウンド機能
- **Markdown**: 構造的編集とプレビュー連携

## 📈 上達のマイルストーン

### 初級（1週間）
- [ ] 基本的なオペレータ + モーション
- [ ] LSPナビゲーション（gd, gr, K）
- [ ] 基本的なコメント操作

### 中級（2-3週間）
- [ ] Treesitterオブジェクト（af, if, ac, ic）
- [ ] LSPコードアクション（<leader>ca）
- [ ] 効率的なエラー修正フロー

### 上級（1ヶ月）
- [ ] 複雑なリファクタリング操作
- [ ] カスタムキーマップ作成
- [ ] 言語別最適化ワークフロー

---

## 💡 次のステップ

このガイドをマスターしたら：
1. `practice/`で実際のコード編集を練習
2. `exercises.md`で統合的な編集タスクに挑戦
3. 自分のプロジェクトでワークフローを最適化

LazyVimの編集機能は使えば使うほど手に馴染み、思考の速度でコード編集ができるようになります。