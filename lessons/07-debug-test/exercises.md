# デバッグ・テスト統合 - エクササイズ

## 準備

### 環境セットアップ
1. TypeScriptプロジェクトのセットアップ
   ```bash
   cd lessons/07-debug-test/practice/typescript-project
   npm install
   ```

2. LazyVimでDAPアダプターの確認
   ```vim
   :Mason
   # node-debug2、js-debug-adapter がインストールされていることを確認
   ```

## エクササイズ1: 基本的なデバッグ操作

### TypeScriptデバッグの練習

1. **最初のブレークポイント**
   - [ ] `src/calculator.ts`を開く
   - [ ] `add`メソッドの最初の行にブレークポイント設定（`<leader>dB`）
   - [ ] デバッグ開始（`<leader>dc`）
   - [ ] プログラムが停止したことを確認

2. **変数の確認**
   - [ ] ブレークポイントで停止中に`<leader>dh`でパラメータ`a`, `b`の値を確認
   - [ ] Variables ウィンドウで変数一覧を確認
   - [ ] `<leader>de`で式`a + b`を評価

3. **ステップ実行**
   - [ ] `<leader>ds`（Step Into）で次の行へ
   - [ ] `<leader>dS`（Step Over）で関数をスキップ
   - [ ] `<leader>dc`（Continue）で次のブレークポイントまで実行

## エクササイズ2: バグの発見と修正

### Calculator クラスのバグ修正

1. **減算バグの修正**
   - [ ] `subtract`メソッドにブレークポイント設定
   - [ ] `calculator.subtract(10, 4)`を実行
   - [ ] 期待値：6、実際：-6 の原因を特定
   - [ ] バグを修正：`b - a` → `a - b`

2. **乗算の無限ループ**
   - [ ] `multiply`メソッドで`b === 0`の場合をテスト
   - [ ] 無限ループが発生することを確認（すぐに停止！）
   - [ ] ゼロ乗算の特別処理を追加

3. **配列操作のエラー**
   - [ ] `average([])`を実行してNaN問題を特定
   - [ ] `findMax([])`で undefined アクセスエラーを特定
   - [ ] 適切なエラーハンドリングを追加

## エクササイズ3: 条件付きブレークポイント

### 高度なデバッグテクニック

1. **条件付きブレークポイント**
   ```vim
   " multiply メソッドで b === 0 の時のみ停止
   :lua require('dap').set_breakpoint(vim.fn.input('Breakpoint condition: '))
   # 入力: b === 0
   ```

2. **ログポイント**
   ```vim
   " history配列の長さをログ出力（停止はしない）
   :lua require('dap').set_breakpoint(nil, nil, vim.fn.input('Log point message: '))
   # 入力: History length: {#history}
   ```

3. **例外ブレークポイント**
   ```vim
   " 全ての例外で自動停止
   :lua require('dap').set_exception_breakpoints({'all'})
   ```

## エクササイズ4: 非同期コードのデバッグ

### TaskManager の非同期バグ

1. **レースコンディションの調査**
   - [ ] `TaskManager.addTask`で同時実行テスト
   - [ ] ID生成の競合状態を確認
   - [ ] 複数のタスクが同じIDを持つ問題を特定

2. **Promise チェーンのデバッグ**
   - [ ] `processHighPriorityTasks`にブレークポイント
   - [ ] 非同期ループ内での状態変化を追跡
   - [ ] concurrent modification の問題を確認

3. **async/await のステップ実行**
   - [ ] `await`文でのステップ実行を練習
   - [ ] Promise の解決を待つデバッグフロー

## エクササイズ5: テストの実行と統合

### Jest テストでの練習

1. **テスト実行**
   ```bash
   npm test
   ```
   - [ ] 失敗するテストの確認
   - [ ] テスト結果の分析

2. **テストデバッグ**
   - [ ] `__tests__/calculator.test.ts`のテストにブレークポイント設定
   - [ ] テストのデバッグ実行：
   ```bash
   npm run test:debug
   ```
   - [ ] デバッガーがテストコードで停止することを確認

3. **neotest統合**
   ```vim
   <leader>tr  " 最寄りのテストを実行
   <leader>tR  " ファイル内の全テストを実行
   <leader>to  " テスト出力を確認
   ```

## エクササイズ6: メモリリークの調査

### パフォーマンス問題の特定

1. **メモリ使用量の監視**
   - [ ] `DataProcessor`でメモリリークを調査
   - [ ] 大量データ処理時のメモリ増加を確認
   - [ ] Node.js プロファイラーの活用

2. **文字列連結パフォーマンス**
   - [ ] `generateReport`メソッドの性能問題を特定
   - [ ] 大量データでの文字列連結を最適化

## エクササイズ7: 実践的なデバッグシナリオ

### 複合的な問題の解決

1. **ユーザー報告のバグ再現**
   
   **症状**: "タスクを削除したのに統計に残っている"
   
   - [ ] 再現手順を作成
   - [ ] TaskManager で該当機能をデバッグ
   - [ ] 統計計算のバグを特定・修正

2. **パフォーマンス劣化の調査**
   
   **症状**: "大量データ処理が異常に遅い"
   
   - [ ] プロファイリングでボトルネック特定
   - [ ] 非効率なアルゴリズムを発見
   - [ ] 最適化による改善効果を測定

3. **間欠的なエラーの調査**
   
   **症状**: "時々テストが失敗する"
   
   - [ ] レースコンディションの可能性を調査
   - [ ] テストの安定性を向上

## エクササイズ8: TDD ワークフロー実践

### テスト駆動開発の練習

1. **新機能のTDD実装**
   
   **機能**: Calculator に三角関数を追加
   
   ```typescript
   // 1. Red: 失敗するテストを書く
   test('should calculate sine correctly', () => {
     expect(calculator.sin(Math.PI / 2)).toBeCloseTo(1);
   });
   ```
   
   - [ ] テストを実行して失敗を確認（`<leader>tr`）
   - [ ] 最小限の実装を追加
   - [ ] テストが通ることを確認
   - [ ] リファクタリング

2. **BDD スタイルのテスト**
   
   ```typescript
   describe('when calculating statistics', () => {
     describe('given an empty task list', () => {
       it('should return zero completion rate', () => {
         // テスト実装
       });
     });
   });
   ```

## エクササイズ9: カバレッジ分析

### テストカバレッジの向上

1. **カバレッジレポート生成**
   ```bash
   npm run test:coverage
   ```
   - [ ] カバレッジ不足の箇所を特定
   - [ ] 未テスト関数を特定

2. **カバレッジ向上**
   - [ ] カバレッジが低い関数のテストを追加
   - [ ] エッジケースのテストを書く
   - [ ] カバレッジ80%以上を目標

## エクササイズ10: 統合デバッグ

### 複数ファイルにまたがる問題

1. **クロスファイル依存関係**
   - [ ] `index.ts` → `Calculator` → `TaskManager` の呼び出しフローをデバッグ
   - [ ] ファイル間でのデータ受け渡しを追跡
   - [ ] Call Stack を使った関数呼び出し階層の確認

2. **統合テストのデバッグ**
   - [ ] 複数のクラスを組み合わせたテスト
   - [ ] 統合レベルでの問題特定

## チャレンジ課題

### 上級1: カスタムデバッグ設定
- [ ] VSCode互換のlaunch.json設定を作成
- [ ] 環境変数を使ったデバッグ設定
- [ ] リモートデバッグの設定

### 上級2: プロファイリング統合
- [ ] Node.js プロファイラーとの統合
- [ ] メモリ使用量のリアルタイム監視
- [ ] パフォーマンスボトルネックの自動検出

### 上級3: CI/CD統合
- [ ] GitHub Actionsでのテスト自動実行
- [ ] テスト失敗時の自動デバッグ情報収集
- [ ] カバレッジレポートの自動生成

## 確認ポイント

練習後、以下を確認してください：

1. **デバッグ操作**
   - [ ] ブレークポイントの設定・削除ができる
   - [ ] ステップ実行（into, over, out）を使い分けられる
   - [ ] 変数の値を効率的に確認できる

2. **高度なデバッグ**
   - [ ] 条件付きブレークポイントを活用できる
   - [ ] 非同期コードをデバッグできる
   - [ ] 例外発生時に適切に調査できる

3. **テスト統合**
   - [ ] テストの実行・結果確認ができる
   - [ ] テストをデバッグできる
   - [ ] TDDワークフローを実践できる

4. **問題解決**
   - [ ] 症状から原因を効率的に特定できる
   - [ ] パフォーマンス問題を調査できる
   - [ ] 修正後の検証を適切に行える